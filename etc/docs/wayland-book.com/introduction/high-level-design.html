<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>High-level Wayland design - The Wayland Protocol</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/high-level-design.html" class="active"><strong aria-hidden="true">1.1.</strong> High-level Wayland design</a></li><li class="chapter-item expanded "><a href="../introduction/goals.html"><strong aria-hidden="true">1.2.</strong> Goals & target audience</a></li><li class="chapter-item expanded "><a href="../introduction/package.html"><strong aria-hidden="true">1.3.</strong> What's in the package</a></li></ol></li><li class="chapter-item expanded "><a href="../protocol-design.html"><strong aria-hidden="true">2.</strong> Protocol design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../protocol-design/wire-protocol.html"><strong aria-hidden="true">2.1.</strong> Wire protocol basics</a></li><li class="chapter-item expanded "><a href="../protocol-design/interfaces-reqs-events.html"><strong aria-hidden="true">2.2.</strong> Interfaces, requests, events</a></li><li class="chapter-item expanded "><a href="../protocol-design/high-level.html"><strong aria-hidden="true">2.3.</strong> The high-level protocol</a></li><li class="chapter-item expanded "><a href="../protocol-design/design-patterns.html"><strong aria-hidden="true">2.4.</strong> Protocol design patterns</a></li></ol></li><li class="chapter-item expanded "><a href="../libwayland.html"><strong aria-hidden="true">3.</strong> libwayland in depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../libwayland/util.html"><strong aria-hidden="true">3.1.</strong> wayland-util primitives</a></li><li class="chapter-item expanded "><a href="../libwayland/wayland-scanner.html"><strong aria-hidden="true">3.2.</strong> wayland-scanner</a></li><li class="chapter-item expanded "><a href="../libwayland/proxies.html"><strong aria-hidden="true">3.3.</strong> Proxies & resources</a></li><li class="chapter-item expanded "><a href="../libwayland/interfaces.html"><strong aria-hidden="true">3.4.</strong> Interfaces & listeners</a></li></ol></li><li class="chapter-item expanded "><a href="../wayland-display.html"><strong aria-hidden="true">4.</strong> The Wayland display</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../wayland-display/creation.html"><strong aria-hidden="true">4.1.</strong> Creating a display</a></li><li class="chapter-item expanded "><a href="../wayland-display/event-loop.html"><strong aria-hidden="true">4.2.</strong> Incorporating an event loop</a></li></ol></li><li class="chapter-item expanded "><a href="../registry.html"><strong aria-hidden="true">5.</strong> Globals & the registry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../registry/binding.html"><strong aria-hidden="true">5.1.</strong> Binding to globals</a></li><li class="chapter-item expanded "><a href="../registry/server-side.html"><strong aria-hidden="true">5.2.</strong> Registering globals</a></li></ol></li><li class="chapter-item expanded "><a href="../surfaces.html"><strong aria-hidden="true">6.</strong> Buffers & surfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../surfaces/compositor.html"><strong aria-hidden="true">6.1.</strong> Using wl_compositor</a></li><li class="chapter-item expanded "><a href="../surfaces/shared-memory.html"><strong aria-hidden="true">6.2.</strong> Shared memory buffers</a></li><li class="chapter-item expanded "><a href="../surfaces/dmabuf.html"><strong aria-hidden="true">6.3.</strong> Linux dmabuf</a></li><li class="chapter-item expanded "><a href="../surfaces/roles.html"><strong aria-hidden="true">6.4.</strong> Surface roles</a></li></ol></li><li class="chapter-item expanded "><a href="../xdg-shell-basics.html"><strong aria-hidden="true">7.</strong> XDG shell basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../xdg-shell-basics/xdg-surface.html"><strong aria-hidden="true">7.1.</strong> XDG surfaces</a></li><li class="chapter-item expanded "><a href="../xdg-shell-basics/xdg-toplevel.html"><strong aria-hidden="true">7.2.</strong> Application windows</a></li><li class="chapter-item expanded "><a href="../xdg-shell-basics/example-code.html"><strong aria-hidden="true">7.3.</strong> Extended example code</a></li></ol></li><li class="chapter-item expanded "><a href="../surfaces-in-depth.html"><strong aria-hidden="true">8.</strong> Surfaces in depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../surfaces-in-depth/lifecycle.html"><strong aria-hidden="true">8.1.</strong> Surface lifecycle</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/frame-callbacks.html"><strong aria-hidden="true">8.2.</strong> Frame callbacks</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/damaging-surfaces.html"><strong aria-hidden="true">8.3.</strong> Damaging surfaces</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/surface-regions.html"><strong aria-hidden="true">8.4.</strong> Surface regions</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/subsurfaces.html"><strong aria-hidden="true">8.5.</strong> Subsurfaces</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/hidpi.html"><strong aria-hidden="true">8.6.</strong> High density surfaces (HiDPI)</a></li></ol></li><li class="chapter-item expanded "><a href="../seat.html"><strong aria-hidden="true">9.</strong> Seats: Handling input</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../seat/pointer.html"><strong aria-hidden="true">9.1.</strong> Pointer input</a></li><li class="chapter-item expanded "><a href="../seat/xkb.html"><strong aria-hidden="true">9.2.</strong> XKB, briefly</a></li><li class="chapter-item expanded "><a href="../seat/keyboard.html"><strong aria-hidden="true">9.3.</strong> Keyboard input</a></li><li class="chapter-item expanded "><a href="../seat/touch.html"><strong aria-hidden="true">9.4.</strong> Touch input</a></li><li class="chapter-item expanded "><a href="../seat/example.html"><strong aria-hidden="true">9.5.</strong> Expanding our example code</a></li></ol></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth.html"><strong aria-hidden="true">10.</strong> XDG shell in depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/configuration.html"><strong aria-hidden="true">10.1.</strong> Configuration & lifecycle</a></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/popups.html"><strong aria-hidden="true">10.2.</strong> Popups & parent windows</a></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/interactive.html"><strong aria-hidden="true">10.3.</strong> Interactive move and resize</a></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/positioners.html"><strong aria-hidden="true">10.4.</strong> Positioners</a></li></ol></li><li class="chapter-item expanded "><a href="../clipboard.html"><strong aria-hidden="true">11.</strong> Clipboard access</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../clipboard/data-offers.html"><strong aria-hidden="true">11.1.</strong> Data offers</a></li><li class="chapter-item expanded "><a href="../clipboard/dnd.html"><strong aria-hidden="true">11.2.</strong> Drag & drop</a></li></ol></li><li class="chapter-item expanded "><a href="../protocol-extensions.html"><strong aria-hidden="true">12.</strong> Protocol extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../protocol-extensions/timing.html"><strong aria-hidden="true">12.1.</strong> Accurate timing</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/pointer-constraints.html"><strong aria-hidden="true">12.2.</strong> Pointer constraints</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/clipboard.html"><strong aria-hidden="true">12.3.</strong> Extended clipboard support</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/desktop-shell.html"><strong aria-hidden="true">12.4.</strong> Desktop shell components</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/misc.html"><strong aria-hidden="true">12.5.</strong> Miscellaneous extensions</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/writing.html"><strong aria-hidden="true">12.6.</strong> Writing new extensions</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../acknowledgements.html">Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <h1 class="menu-title">The Wayland Protocol</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="high-level-design"><a class="header" href="#high-level-design">High-level design</a></h1>
<p>Your computer has <em>input</em> and <em>output</em> devices, which respectively are
responsible for receiving information from you and displaying information to
you. These input devices take the form of, for example:</p>
<ul>
<li>Keyboards</li>
<li>Mice</li>
<li>Touchpads</li>
<li>Touch screens</li>
<li>Drawing tablets</li>
</ul>
<p>Your output devices generally take the form of displays, on your desk or your
laptop or mobile device. These resources are shared between all of your
applications, and the role of the <strong>Wayland compositor</strong> is to dispatch input
events to the appropriate <strong>Wayland client</strong> and to display their windows in
their appropriate place on your outputs. The process of bringing together all of
your application windows for display on an output is called <em>compositing</em> 
— and thus we call the software which does this the <em>compositor</em>.</p>
<h2 id="in-practice"><a class="header" href="#in-practice">In practice</a></h2>
<p>There are many distinct software components in desktop ecosystem. There are
tools like Mesa for rendering (and each of its drivers), the Linux KMS/DRM
subsystem, buffer allocation with GBM, the userspace libdrm library, libinput
and evdev, and much more still. Don't worry — expertise with most of these
systems is not required for understanding Wayland, and in any case are largely
beyond the scope of this book. In fact, the Wayland protocol is quite
conservative and abstract, and a Wayland-based desktop could easily be built &amp;
run most applications without implicating any of this software. That being said,
a surface-level understanding of what these pieces are and how they work is
useful. Let's start from the bottom and work our way up.</p>
<h2 id="the-hardware"><a class="header" href="#the-hardware">The hardware</a></h2>
<p>A typical computer is equipped with a few important pieces of hardware. Outside
of the box, we have your displays, keyboard, mouse, perhaps some speakers and a
cute USB cup warmer. There are several components <em>inside</em> the box for
interfacing with these devices. Your keyboard and mouse, for example, are
probably plugged into USB ports, for which your system has a dedicated USB
controller. Your displays are plugged into your GPU.</p>
<p>These systems have their own jobs and state. For example, your GPU has state
in the form of memory for storing pixel buffers in, and jobs like <em>scanning
out</em> these buffers to your displays. Your GPU also provides a processor which is
specially tuned to be good at highly parallel jobs (such as calculating the
right color for each of the 2,073,600 pixels on a 1080p display), and bad at
everything else. The USB controller has the unenviable job of implementing the
legendarily dry USB specification for receiving input events from your keyboard,
or instructing your coaster to assume a temperature carefully selected to at
once avoid lawsuits and frustrate you with cold coffee.</p>
<p>At this level, your hardware has little concept of what applications are running
on your system. The hardware provides an interface with which it can be
commanded to perform work, and does what it's told — regardless of who 
tells it so. For this reason, only one component is allowed to talk to it...</p>
<h2 id="the-kernel"><a class="header" href="#the-kernel">The kernel</a></h2>
<p>This responsibility falls onto the kernel. The kernel is a complex beast, so
we'll focus on only the parts which are relevant to Wayland. Linux's job is to
provide an abstraction over your hardware, so that it can be safely accessed
by <em>userspace</em> — where our Wayland compositors run. For graphics, this is
called the <strong>DRM</strong>, or <em>direct rendering manager</em>, which efficiently tasks the
GPU with work from userspace. An important subsystem of DRM is <strong>KMS</strong>, or
<em>kernel mode setting</em>, for enumerating your displays and setting properties such
as their selected resolution (also known as their &quot;mode&quot;). Input devices are
abstracted through an interface called <strong>evdev</strong>.</p>
<p>Most kernel interfaces are made available to userspace by way of special files
in <code>/dev</code>. In the case of DRM, these files are in <code>/dev/dri/</code>, usually in the
form of a primary node (e.g. <code>card0</code>) for privileged operations like
modesetting, and a render node (e.g. <code>renderD128</code>), for unprivileged operations
like rendering or video decoding. For evdev, the &quot;device nodes&quot; are
<code>/dev/input/event*</code>.</p>
<h2 id="userspace"><a class="header" href="#userspace">Userspace</a></h2>
<p>Now, we enter userspace. Here, applications are isolated from the hardware and
must work via the device nodes provided by the kernel.</p>
<h3 id="libdrm"><a class="header" href="#libdrm">libdrm</a></h3>
<p>Most Linux interfaces have a userspace counterpart which provides a
pleasant(ish) C API for working with these device nodes. One such library is
libdrm, which is the userspace portion of the DRM subsystem. libdrm is used by
Wayland compositors to do modesetting and other DRM operations, but is generally
not used by Wayland clients directly.</p>
<h3 id="mesa"><a class="header" href="#mesa">Mesa</a></h3>
<p>Mesa is one of the most important parts of the Linux graphics stack. It
provides, among other things, vendor-optimized implementations of OpenGL (and
Vulkan) for Linux and the <strong>GBM</strong> (Generic Buffer Management) library — an
abstraction on top of libdrm for allocating buffers on the GPU. Most Wayland
compositors will use both GBM and OpenGL via Mesa, and most Wayland clients will
use at least its OpenGL or Vulkan implementations.</p>
<h3 id="libinput"><a class="header" href="#libinput">libinput</a></h3>
<p>Like libdrm abstracts the DRM subsystem, libinput provides the userspace end of
evdev. It's responsible for receiving input events from the kernel from your
various input devices, decoding them into a usable form, and passing them on to
the Wayland compositor. The Wayland compositor requires special permissions to
use the evdev files, forcing Wayland clients to go through the compositor to
receive input events — which, for example, prevents keylogging.</p>
<h3 id="eudev"><a class="header" href="#eudev">(e)udev</a></h3>
<p>Dealing with the appearance of new devices from the kernel, configuring
permissions for the resulting device nodes in <code>/dev</code>, and sending word of these
changes to applications running on your system, is a responsibility that falls
onto userspace. Most systems use udev (or eudev, a fork) for this purpose. Your
Wayland compositor uses udev to enumerate input devices and GPUs, and to receive
notifications when new ones appear or old ones are unplugged.</p>
<h3 id="xkbcommon"><a class="header" href="#xkbcommon">xkbcommon</a></h3>
<p>XKB, short for X keyboard, is the original keyboard handling subsystem of the
Xorg server. Several years ago, it was extracted from the Xorg tree and made
into an independent library for keyboard handling, and it no longer has any
practical relationship with X. Libinput (along with the Wayland compositor)
delivers keyboard events in the form of scancodes, whose precise meaning varies
from keyboard to keyboard. It's the responsibility of xkbcommon to translate
these scan codes into meaningful and generic key &quot;symbols&quot; — for example,
converting <code>65</code> to <code>XKB_KEY_Space</code>. It also contains a state machine which knows
that pressing &quot;1&quot; while shift is held emits &quot;!&quot;.</p>
<h3 id="pixman"><a class="header" href="#pixman">pixman</a></h3>
<p>A simple library used by clients and compositors alike for efficiently
manipulating pixel buffers, doing math with intersecting rectangles, and
performing other similar <strong>pix</strong>el <strong>man</strong>ipulation tasks.</p>
<h3 id="libwayland"><a class="header" href="#libwayland">libwayland</a></h3>
<p>libwayland the most commonly used implementation of the Wayland protocol,
is written in C, and handles much of the low-level wire protocol. It also
provides a tool which generates high-level code from Wayland protocol
definitions (which are XML files). We will be discussing libwayland in detail in
chapter 1.3, and throughout this book.</p>
<h3 id="and-all-the-rest"><a class="header" href="#and-all-the-rest">...and all the rest.</a></h3>
<p>Each of the pieces mentioned so far are consistently found throughout the Linux
desktop ecosystem. Beyond this, more components exist. Many graphical
applications don't know about Wayland at all, choosing instead to allow
libraries like GTK+, Qt, SDL, and GLFW — among many others — to deal 
with it. Many compositors choose software like wlroots to abstract more of their
responsibilities, while others implement everything in-house.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../introduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../introduction/goals.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a href="../introduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a href="../introduction/goals.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <script src="../book.js" type="text/javascript" charset="utf-8"></script>


    </body>
</html>
