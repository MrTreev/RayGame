<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Expanding our example code - The Wayland Protocol</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/high-level-design.html"><strong aria-hidden="true">1.1.</strong> High-level Wayland design</a></li><li class="chapter-item expanded "><a href="../introduction/goals.html"><strong aria-hidden="true">1.2.</strong> Goals & target audience</a></li><li class="chapter-item expanded "><a href="../introduction/package.html"><strong aria-hidden="true">1.3.</strong> What's in the package</a></li></ol></li><li class="chapter-item expanded "><a href="../protocol-design.html"><strong aria-hidden="true">2.</strong> Protocol design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../protocol-design/wire-protocol.html"><strong aria-hidden="true">2.1.</strong> Wire protocol basics</a></li><li class="chapter-item expanded "><a href="../protocol-design/interfaces-reqs-events.html"><strong aria-hidden="true">2.2.</strong> Interfaces, requests, events</a></li><li class="chapter-item expanded "><a href="../protocol-design/high-level.html"><strong aria-hidden="true">2.3.</strong> The high-level protocol</a></li><li class="chapter-item expanded "><a href="../protocol-design/design-patterns.html"><strong aria-hidden="true">2.4.</strong> Protocol design patterns</a></li></ol></li><li class="chapter-item expanded "><a href="../libwayland.html"><strong aria-hidden="true">3.</strong> libwayland in depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../libwayland/util.html"><strong aria-hidden="true">3.1.</strong> wayland-util primitives</a></li><li class="chapter-item expanded "><a href="../libwayland/wayland-scanner.html"><strong aria-hidden="true">3.2.</strong> wayland-scanner</a></li><li class="chapter-item expanded "><a href="../libwayland/proxies.html"><strong aria-hidden="true">3.3.</strong> Proxies & resources</a></li><li class="chapter-item expanded "><a href="../libwayland/interfaces.html"><strong aria-hidden="true">3.4.</strong> Interfaces & listeners</a></li></ol></li><li class="chapter-item expanded "><a href="../wayland-display.html"><strong aria-hidden="true">4.</strong> The Wayland display</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../wayland-display/creation.html"><strong aria-hidden="true">4.1.</strong> Creating a display</a></li><li class="chapter-item expanded "><a href="../wayland-display/event-loop.html"><strong aria-hidden="true">4.2.</strong> Incorporating an event loop</a></li></ol></li><li class="chapter-item expanded "><a href="../registry.html"><strong aria-hidden="true">5.</strong> Globals & the registry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../registry/binding.html"><strong aria-hidden="true">5.1.</strong> Binding to globals</a></li><li class="chapter-item expanded "><a href="../registry/server-side.html"><strong aria-hidden="true">5.2.</strong> Registering globals</a></li></ol></li><li class="chapter-item expanded "><a href="../surfaces.html"><strong aria-hidden="true">6.</strong> Buffers & surfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../surfaces/compositor.html"><strong aria-hidden="true">6.1.</strong> Using wl_compositor</a></li><li class="chapter-item expanded "><a href="../surfaces/shared-memory.html"><strong aria-hidden="true">6.2.</strong> Shared memory buffers</a></li><li class="chapter-item expanded "><a href="../surfaces/dmabuf.html"><strong aria-hidden="true">6.3.</strong> Linux dmabuf</a></li><li class="chapter-item expanded "><a href="../surfaces/roles.html"><strong aria-hidden="true">6.4.</strong> Surface roles</a></li></ol></li><li class="chapter-item expanded "><a href="../xdg-shell-basics.html"><strong aria-hidden="true">7.</strong> XDG shell basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../xdg-shell-basics/xdg-surface.html"><strong aria-hidden="true">7.1.</strong> XDG surfaces</a></li><li class="chapter-item expanded "><a href="../xdg-shell-basics/xdg-toplevel.html"><strong aria-hidden="true">7.2.</strong> Application windows</a></li><li class="chapter-item expanded "><a href="../xdg-shell-basics/example-code.html"><strong aria-hidden="true">7.3.</strong> Extended example code</a></li></ol></li><li class="chapter-item expanded "><a href="../surfaces-in-depth.html"><strong aria-hidden="true">8.</strong> Surfaces in depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../surfaces-in-depth/lifecycle.html"><strong aria-hidden="true">8.1.</strong> Surface lifecycle</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/frame-callbacks.html"><strong aria-hidden="true">8.2.</strong> Frame callbacks</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/damaging-surfaces.html"><strong aria-hidden="true">8.3.</strong> Damaging surfaces</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/surface-regions.html"><strong aria-hidden="true">8.4.</strong> Surface regions</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/subsurfaces.html"><strong aria-hidden="true">8.5.</strong> Subsurfaces</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/hidpi.html"><strong aria-hidden="true">8.6.</strong> High density surfaces (HiDPI)</a></li></ol></li><li class="chapter-item expanded "><a href="../seat.html"><strong aria-hidden="true">9.</strong> Seats: Handling input</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../seat/pointer.html"><strong aria-hidden="true">9.1.</strong> Pointer input</a></li><li class="chapter-item expanded "><a href="../seat/xkb.html"><strong aria-hidden="true">9.2.</strong> XKB, briefly</a></li><li class="chapter-item expanded "><a href="../seat/keyboard.html"><strong aria-hidden="true">9.3.</strong> Keyboard input</a></li><li class="chapter-item expanded "><a href="../seat/touch.html"><strong aria-hidden="true">9.4.</strong> Touch input</a></li><li class="chapter-item expanded "><a href="../seat/example.html" class="active"><strong aria-hidden="true">9.5.</strong> Expanding our example code</a></li></ol></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth.html"><strong aria-hidden="true">10.</strong> XDG shell in depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/configuration.html"><strong aria-hidden="true">10.1.</strong> Configuration & lifecycle</a></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/popups.html"><strong aria-hidden="true">10.2.</strong> Popups & parent windows</a></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/interactive.html"><strong aria-hidden="true">10.3.</strong> Interactive move and resize</a></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/positioners.html"><strong aria-hidden="true">10.4.</strong> Positioners</a></li></ol></li><li class="chapter-item expanded "><a href="../clipboard.html"><strong aria-hidden="true">11.</strong> Clipboard access</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../clipboard/data-offers.html"><strong aria-hidden="true">11.1.</strong> Data offers</a></li><li class="chapter-item expanded "><a href="../clipboard/dnd.html"><strong aria-hidden="true">11.2.</strong> Drag & drop</a></li></ol></li><li class="chapter-item expanded "><a href="../protocol-extensions.html"><strong aria-hidden="true">12.</strong> Protocol extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../protocol-extensions/timing.html"><strong aria-hidden="true">12.1.</strong> Accurate timing</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/pointer-constraints.html"><strong aria-hidden="true">12.2.</strong> Pointer constraints</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/clipboard.html"><strong aria-hidden="true">12.3.</strong> Extended clipboard support</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/desktop-shell.html"><strong aria-hidden="true">12.4.</strong> Desktop shell components</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/misc.html"><strong aria-hidden="true">12.5.</strong> Miscellaneous extensions</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/writing.html"><strong aria-hidden="true">12.6.</strong> Writing new extensions</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../acknowledgements.html">Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <h1 class="menu-title">The Wayland Protocol</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="expanding-our-example-code"><a class="header" href="#expanding-our-example-code">Expanding our example code</a></h1>
<p>In previous chapters, we built a simple client which can present its surfaces on
the display. Let's expand this code a bit to build a client which can receive
input events. For the sake of simplicity, we're just going to be logging input
events to stderr.</p>
<p>This is going to require a lot more code than we've worked with so far, so get
strapped in. The first thing we need to do is set up the seat.</p>
<h2 id="setting-up-the-seat"><a class="header" href="#setting-up-the-seat">Setting up the seat</a></h2>
<p>The first thing we'll need is a reference to a seat. We'll add it to our
<code>client_state</code> struct, and add keyboard, pointer, and touch objects for later
use as well:</p>
<pre><code class="language-diff">        struct wl_shm *wl_shm;
        struct wl_compositor *wl_compositor;
        struct xdg_wm_base *xdg_wm_base;
+       struct wl_seat *wl_seat;
        /* Objects */
        struct wl_surface *wl_surface;
        struct xdg_surface *xdg_surface;
+       struct wl_keyboard *wl_keyboard;
+       struct wl_pointer *wl_pointer;
+       struct wl_touch *wl_touch;
        /* State */
        float offset;
        uint32_t last_frame;
        int width, height;
</code></pre>
<p>We'll also need to update <code>registry_global</code> to register a listener for that
seat.</p>
<pre><code class="language-diff">                                wl_registry, name, &amp;xdg_wm_base_interface, 1);
                xdg_wm_base_add_listener(state-&gt;xdg_wm_base,
                                &amp;xdg_wm_base_listener, state);
+       } else if (strcmp(interface, wl_seat_interface.name) == 0) {
+               state-&gt;wl_seat = wl_registry_bind(
+                               wl_registry, name, &amp;wl_seat_interface, 7);
+               wl_seat_add_listener(state-&gt;wl_seat,
+                               &amp;wl_seat_listener, state);
        }
 }
</code></pre>
<p>Note that we bind to the latest version of the seat interface, version 7. Let's
also rig up that listener:</p>
<pre><code class="language-diff">+static void
+wl_seat_capabilities(void *data, struct wl_seat *wl_seat, uint32_t capabilities)
+{
+       struct client_state *state = data;
+       /* TODO */
+}
+
+static void
+wl_seat_name(void *data, struct wl_seat *wl_seat, const char *name)
+{
+       fprintf(stderr, &quot;seat name: %s\n&quot;, name);
+}
+
+static const struct wl_seat_listener wl_seat_listener = {
+       .capabilities = wl_seat_capabilities,
+       .name = wl_seat_name,
+};
</code></pre>
<p>If you compile (<code>cc -o client client.c xdg-shell-protocol.c</code>) and run this now,
you should seat the name of the seat printed to stderr.</p>
<h2 id="rigging-up-pointer-events"><a class="header" href="#rigging-up-pointer-events">Rigging up pointer events</a></h2>
<p>Let's get to pointer events. If you recall, pointer events from the Wayland
server are to be accumulated into a single logical event. For this reason, we'll
need to define a struct to store them in.</p>
<pre><code class="language-diff">+enum pointer_event_mask {
+       POINTER_EVENT_ENTER = 1 &lt;&lt; 0,
+       POINTER_EVENT_LEAVE = 1 &lt;&lt; 1,
+       POINTER_EVENT_MOTION = 1 &lt;&lt; 2,
+       POINTER_EVENT_BUTTON = 1 &lt;&lt; 3,
+       POINTER_EVENT_AXIS = 1 &lt;&lt; 4,
+       POINTER_EVENT_AXIS_SOURCE = 1 &lt;&lt; 5,
+       POINTER_EVENT_AXIS_STOP = 1 &lt;&lt; 6,
+       POINTER_EVENT_AXIS_DISCRETE = 1 &lt;&lt; 7,
+};
+
+struct pointer_event {
+       uint32_t event_mask;
+       wl_fixed_t surface_x, surface_y;
+       uint32_t button, state;
+       uint32_t time;
+       uint32_t serial;
+       struct {
+               bool valid;
+               wl_fixed_t value;
+               int32_t discrete;
+       } axes[2];
+       uint32_t axis_source;
+};
</code></pre>
<p>We'll be using a bitmask here to identify which events we've received for a
single pointer frame, and storing the relevant information from each event in
their respective fields. Let's add this to our state struct as well:</p>
<pre><code class="language-diff">        /* State */
        float offset;
        uint32_t last_frame;
        int width, height;
        bool closed;
+       struct pointer_event pointer_event;
 };
</code></pre>
<p>Then we'll need to update our <code>wl_seat_capabilities</code> to set up the pointer
object for seats which are capable of pointer input.</p>
<pre><code class="language-diff"> static void
 wl_seat_capabilities(void *data, struct wl_seat *wl_seat, uint32_t capabilities)
 {
        struct client_state *state = data;
-       /* TODO */
+
+       bool have_pointer = capabilities &amp; WL_SEAT_CAPABILITY_POINTER;
+
+       if (have_pointer &amp;&amp; state-&gt;wl_pointer == NULL) {
+               state-&gt;wl_pointer = wl_seat_get_pointer(state-&gt;wl_seat);
+               wl_pointer_add_listener(state-&gt;wl_pointer,
+                               &amp;wl_pointer_listener, state);
+       } else if (!have_pointer &amp;&amp; state-&gt;wl_pointer != NULL) {
+               wl_pointer_release(state-&gt;wl_pointer);
+               state-&gt;wl_pointer = NULL;
+       }
 }
</code></pre>
<p>This merits some explanation. Recall that <code>capabilities</code> is a bitmask of the
kinds of devices supported by this seat — a bitwise AND (&amp;) with a capability
will produce a non-zero value if supported. Then, if we have a pointer and have
<em>not</em> already configured it, we take the first branch, using
<code>wl_seat_get_pointer</code> to obtain a pointer reference and storing it in our state.
If the seat does <em>not</em> support pointers, but we already have one configured, we
use <code>wl_pointer_release</code> to get rid of it. Remember that the capabilities of a
seat can change at runtime, for example when the user un-plugs and re-plugs
their mouse.</p>
<p>We also configured a listener for the pointer. Let's add the struct for that,
too:</p>
<pre><code class="language-diff">+static const struct wl_pointer_listener wl_pointer_listener = {
+       .enter = wl_pointer_enter,
+       .leave = wl_pointer_leave,
+       .motion = wl_pointer_motion,
+       .button = wl_pointer_button,
+       .axis = wl_pointer_axis,
+       .frame = wl_pointer_frame,
+       .axis_source = wl_pointer_axis_source,
+       .axis_stop = wl_pointer_axis_stop,
+       .axis_discrete = wl_pointer_axis_discrete,
+};
</code></pre>
<p>Pointers have a lot of events. Let's have a look at them.</p>
<pre><code class="language-diff">+static void
+wl_pointer_enter(void *data, struct wl_pointer *wl_pointer,
+               uint32_t serial, struct wl_surface *surface,
+               wl_fixed_t surface_x, wl_fixed_t surface_y)
+{
+       struct client_state *client_state = data;
+       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_ENTER;
+       client_state-&gt;pointer_event.serial = serial;
+       client_state-&gt;pointer_event.surface_x = surface_x,
+               client_state-&gt;pointer_event.surface_y = surface_y;
+}
+
+static void
+wl_pointer_leave(void *data, struct wl_pointer *wl_pointer,
+               uint32_t serial, struct wl_surface *surface)
+{
+       struct client_state *client_state = data;
+       client_state-&gt;pointer_event.serial = serial;
+       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_LEAVE;
+}
</code></pre>
<p>The &quot;enter&quot; and &quot;leave&quot; events are fairly straightforward, and they set the
stage for the rest of the implementation. We update the event mask to include
the appropriate event, then populate it with the data we were provided. The
&quot;motion&quot; and &quot;button&quot; events are rather similar:</p>
<pre><code class="language-diff">+static void
+wl_pointer_motion(void *data, struct wl_pointer *wl_pointer, uint32_t time,
+               wl_fixed_t surface_x, wl_fixed_t surface_y)
+{
+       struct client_state *client_state = data;
+       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_MOTION;
+       client_state-&gt;pointer_event.time = time;
+       client_state-&gt;pointer_event.surface_x = surface_x,
+               client_state-&gt;pointer_event.surface_y = surface_y;
+}
+
+static void
+wl_pointer_button(void *data, struct wl_pointer *wl_pointer, uint32_t serial,
+               uint32_t time, uint32_t button, uint32_t state)
+{
+       struct client_state *client_state = data;
+       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_BUTTON;
+       client_state-&gt;pointer_event.time = time;
+       client_state-&gt;pointer_event.serial = serial;
+       client_state-&gt;pointer_event.button = button,
+               client_state-&gt;pointer_event.state = state;
+}
</code></pre>
<p>Axis events are somewhat more complex, because there are two axes: horizontal
and vertical. Thus, our <code>pointer_event</code> struct contains an array with two groups
of axis events. Our code to handle these ends up something like this:</p>
<pre><code class="language-diff">+static void
+wl_pointer_axis(void *data, struct wl_pointer *wl_pointer, uint32_t time,
+               uint32_t axis, wl_fixed_t value)
+{
+       struct client_state *client_state = data;
+       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_AXIS;
+       client_state-&gt;pointer_event.time = time;
+       client_state-&gt;pointer_event.axes[axis].valid = true;
+       client_state-&gt;pointer_event.axes[axis].value = value;
+}
+
+static void
+wl_pointer_axis_source(void *data, struct wl_pointer *wl_pointer,
+               uint32_t axis_source)
+{
+       struct client_state *client_state = data;
+       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_AXIS_SOURCE;
+       client_state-&gt;pointer_event.axis_source = axis_source;
+}
+
+static void
+wl_pointer_axis_stop(void *data, struct wl_pointer *wl_pointer,
+               uint32_t time, uint32_t axis)
+{
+       struct client_state *client_state = data;
+       client_state-&gt;pointer_event.time = time;
+       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_AXIS_STOP;
+       client_state-&gt;pointer_event.axes[axis].valid = true;
+}
+
+static void
+wl_pointer_axis_discrete(void *data, struct wl_pointer *wl_pointer,
+               uint32_t axis, int32_t discrete)
+{
+       struct client_state *client_state = data;
+       client_state-&gt;pointer_event.event_mask |= POINTER_EVENT_AXIS_DISCRETE;
+       client_state-&gt;pointer_event.axes[axis].valid = true;
+       client_state-&gt;pointer_event.axes[axis].discrete = discrete;
+}
</code></pre>
<p>Similarly straightforward, aside from the main change of updating whichever axis
was affected. Note the use of the &quot;valid&quot; boolean as well: it's possible that
we'll receive a pointer frame which updates one axis, but not another, so we use
this &quot;valid&quot; value to determine which axes were updated in the frame event.</p>
<p>Speaking of which, it's time for the main attraction: our &quot;frame&quot; handler.</p>
<pre><code class="language-diff">+static void
+wl_pointer_frame(void *data, struct wl_pointer *wl_pointer)
+{
+       struct client_state *client_state = data;
+       struct pointer_event *event = &amp;client_state-&gt;pointer_event;
+       fprintf(stderr, &quot;pointer frame @ %d: &quot;, event-&gt;time);
+
+       if (event-&gt;event_mask &amp; POINTER_EVENT_ENTER) {
+               fprintf(stderr, &quot;entered %f, %f &quot;,
+                               wl_fixed_to_double(event-&gt;surface_x),
+                               wl_fixed_to_double(event-&gt;surface_y));
+       }
+
+       if (event-&gt;event_mask &amp; POINTER_EVENT_LEAVE) {
+               fprintf(stderr, &quot;leave&quot;);
+       }
+
+       if (event-&gt;event_mask &amp; POINTER_EVENT_MOTION) {
+               fprintf(stderr, &quot;motion %f, %f &quot;,
+                               wl_fixed_to_double(event-&gt;surface_x),
+                               wl_fixed_to_double(event-&gt;surface_y));
+       }
+
+       if (event-&gt;event_mask &amp; POINTER_EVENT_BUTTON) {
+               char *state = event-&gt;state == WL_POINTER_BUTTON_STATE_RELEASED ?
+                       &quot;released&quot; : &quot;pressed&quot;;
+               fprintf(stderr, &quot;button %d %s &quot;, event-&gt;button, state);
+       }
+
+       uint32_t axis_events = POINTER_EVENT_AXIS
+               | POINTER_EVENT_AXIS_SOURCE
+               | POINTER_EVENT_AXIS_STOP
+               | POINTER_EVENT_AXIS_DISCRETE;
+       char *axis_name[2] = {
+               [WL_POINTER_AXIS_VERTICAL_SCROLL] = &quot;vertical&quot;,
+               [WL_POINTER_AXIS_HORIZONTAL_SCROLL] = &quot;horizontal&quot;,
+       };
+       char *axis_source[4] = {
+               [WL_POINTER_AXIS_SOURCE_WHEEL] = &quot;wheel&quot;,
+               [WL_POINTER_AXIS_SOURCE_FINGER] = &quot;finger&quot;,
+               [WL_POINTER_AXIS_SOURCE_CONTINUOUS] = &quot;continuous&quot;,
+               [WL_POINTER_AXIS_SOURCE_WHEEL_TILT] = &quot;wheel tilt&quot;,
+       };
+       if (event-&gt;event_mask &amp; axis_events) {
+               for (size_t i = 0; i &lt; 2; ++i) {
+                       if (!event-&gt;axes[i].valid) {
+                               continue;
+                       }
+                       fprintf(stderr, &quot;%s axis &quot;, axis_name[i]);
+                       if (event-&gt;event_mask &amp; POINTER_EVENT_AXIS) {
+                               fprintf(stderr, &quot;value %f &quot;, wl_fixed_to_double(
+                                                       event-&gt;axes[i].value));
+                       }
+                       if (event-&gt;event_mask &amp; POINTER_EVENT_AXIS_DISCRETE) {
+                               fprintf(stderr, &quot;discrete %d &quot;,
+                                               event-&gt;axes[i].discrete);
+                       }
+                       if (event-&gt;event_mask &amp; POINTER_EVENT_AXIS_SOURCE) {
+                               fprintf(stderr, &quot;via %s &quot;,
+                                               axis_source[event-&gt;axis_source]);
+                       }
+                       if (event-&gt;event_mask &amp; POINTER_EVENT_AXIS_STOP) {
+                               fprintf(stderr, &quot;(stopped) &quot;);
+                       }
+               }
+       }
+
+       fprintf(stderr, &quot;\n&quot;);
+       memset(event, 0, sizeof(*event));
+}
</code></pre>
<p>It certainly is the longest of the bunch, isn't it? Hopefully it isn't too
confusing, though. All we're doing here is pretty-printing the accumulated state
for this frame to stderr. If you compile and run this again now, you should be
able to wiggle your mouse over the window and see input events printed out!</p>
<h2 id="rigging-up-keyboard-events"><a class="header" href="#rigging-up-keyboard-events">Rigging up keyboard events</a></h2>
<p>Let's update our <code>client_state</code> struct with some fields to store XKB state.</p>
<pre><code class="language-diff">@@ -105,6 +107,9 @@ struct client_state {
        int width, height;
        bool closed;
        struct pointer_event pointer_event;
+       struct xkb_state *xkb_state;
+       struct xkb_context *xkb_context;
+       struct xkb_keymap *xkb_keymap;
};
</code></pre>
<p>We need the xkbcommon headers to define these. While we're at it, I'm going to
pull in <code>assert.h</code> as well:</p>
<pre><code class="language-diff">@@ -1,4 +1,5 @@
 #define _POSIX_C_SOURCE 200112L
+#include &lt;assert.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;fcntl.h&gt;
 #include &lt;limits.h&gt;
@@ -9,6 +10,7 @@
 #include &lt;time.h&gt;
 #include &lt;unistd.h&gt;
 #include &lt;wayland-client.h&gt;
+#include &lt;xkbcommon/xkbcommon.h&gt;
 #include &quot;xdg-shell-client-protocol.h&quot;
</code></pre>
<p>We'll also need to initialize the xkb_context in our main function:</p>
<pre><code class="language-diff">@@ -603,6 +649,7 @@ main(int argc, char *argv[])
        state.height = 480;
        state.wl_display = wl_display_connect(NULL);
        state.wl_registry = wl_display_get_registry(state.wl_display);
+       state.xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
        wl_registry_add_listener(state.wl_registry, &amp;wl_registry_listener, &amp;state);
        wl_display_roundtrip(state.wl_display);
</code></pre>
<p>Next, let's update our seat capabilities function to rig up our keyboard
listener, too.</p>
<pre><code class="language-diff">        } else if (!have_pointer &amp;&amp; state-&gt;wl_pointer != NULL) {
                wl_pointer_release(state-&gt;wl_pointer);
                state-&gt;wl_pointer = NULL;
        }
+
+       bool have_keyboard = capabilities &amp; WL_SEAT_CAPABILITY_KEYBOARD;
+
+       if (have_keyboard &amp;&amp; state-&gt;wl_keyboard == NULL) {
+               state-&gt;wl_keyboard = wl_seat_get_keyboard(state-&gt;wl_seat);
+               wl_keyboard_add_listener(state-&gt;wl_keyboard,
+                               &amp;wl_keyboard_listener, state);
+       } else if (!have_keyboard &amp;&amp; state-&gt;wl_keyboard != NULL) {
+               wl_keyboard_release(state-&gt;wl_keyboard);
+               state-&gt;wl_keyboard = NULL;
+       }
 }
</code></pre>
<p>We'll have to define the <code>wl_keyboard_listener</code> we use here, too.</p>
<pre><code class="language-diff">+static const struct wl_keyboard_listener wl_keyboard_listener = {
+       .keymap = wl_keyboard_keymap,
+       .enter = wl_keyboard_enter,
+       .leave = wl_keyboard_leave,
+       .key = wl_keyboard_key,
+       .modifiers = wl_keyboard_modifiers,
+       .repeat_info = wl_keyboard_repeat_info,
+};
</code></pre>
<p>And now, the meat of the changes. Let's start with the keymap:</p>
<pre><code class="language-diff">+static void
+wl_keyboard_keymap(void *data, struct wl_keyboard *wl_keyboard,
+               uint32_t format, int32_t fd, uint32_t size)
+{
+       struct client_state *client_state = data;
+       assert(format == WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1);
+
+       char *map_shm = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
+       assert(map_shm != MAP_FAILED);
+
+       struct xkb_keymap *xkb_keymap = xkb_keymap_new_from_string(
+                       client_state-&gt;xkb_context, map_shm,
+                       XKB_KEYMAP_FORMAT_TEXT_V1, XKB_KEYMAP_COMPILE_NO_FLAGS);
+       munmap(map_shm, size);
+       close(fd);
+
+       struct xkb_state *xkb_state = xkb_state_new(xkb_keymap);
+       xkb_keymap_unref(client_state-&gt;xkb_keymap);
+       xkb_state_unref(client_state-&gt;xkb_state);
+       client_state-&gt;xkb_keymap = xkb_keymap;
+       client_state-&gt;xkb_state = xkb_state;
+}
</code></pre>
<p>Now we can see why we added <code>assert.h</code> — we're using it here to make sure
that the keymap format is the one we expect. Then, we use mmap to map the file
descriptor the compositor sent us to a <code>char *</code> pointer we can pass into
<code>xkb_keymap_new_from_string</code>. Don't forget to munmap and close that fd
afterwards — then we set up our XKB state. Note as well that we have also
unrefed any previous XKB keymap or state that we had set up in a prior call to
this function, in case the compositor changes the keymap at runtime.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<pre><code class="language-diff">+static void
+wl_keyboard_enter(void *data, struct wl_keyboard *wl_keyboard,
+               uint32_t serial, struct wl_surface *surface,
+               struct wl_array *keys)
+{
+       struct client_state *client_state = data;
+       fprintf(stderr, &quot;keyboard enter; keys pressed are:\n&quot;);
+       uint32_t *key;
+       wl_array_for_each(key, keys) {
+               char buf[128];
+               xkb_keysym_t sym = xkb_state_key_get_one_sym(
+                               client_state-&gt;xkb_state, *key + 8);
+               xkb_keysym_get_name(sym, buf, sizeof(buf));
+               fprintf(stderr, &quot;sym: %-12s (%d), &quot;, buf, sym);
+               xkb_state_key_get_utf8(client_state-&gt;xkb_state,
+                               *key + 8, buf, sizeof(buf));
+               fprintf(stderr, &quot;utf8: '%s'\n&quot;, buf);
+       }
+}
</code></pre>
<p>When the keyboard &quot;enters&quot; our surface, we have received keyboard focus. The
compositor forwards a list of keys which were already pressed at that time, and
here we just enumerate them and log their keysym names and UTF-8 equivalent.
We'll do something similar when keys are pressed:</p>
<pre><code class="language-diff">+static void
+wl_keyboard_key(void *data, struct wl_keyboard *wl_keyboard,
+               uint32_t serial, uint32_t time, uint32_t key, uint32_t state)
+{
+       struct client_state *client_state = data;
+       char buf[128];
+       uint32_t keycode = key + 8;
+       xkb_keysym_t sym = xkb_state_key_get_one_sym(
+                       client_state-&gt;xkb_state, keycode);
+       xkb_keysym_get_name(sym, buf, sizeof(buf));
+       const char *action =
+               state == WL_KEYBOARD_KEY_STATE_PRESSED ? &quot;press&quot; : &quot;release&quot;;
+       fprintf(stderr, &quot;key %s: sym: %-12s (%d), &quot;, action, buf, sym);
+       xkb_state_key_get_utf8(client_state-&gt;xkb_state, keycode,
+                       buf, sizeof(buf));
+       fprintf(stderr, &quot;utf8: '%s'\n&quot;, buf);
+}
</code></pre>
<p>And finally, we add small implementations of the three remaining events:</p>
<pre><code class="language-diff">+static void
+wl_keyboard_leave(void *data, struct wl_keyboard *wl_keyboard,
+               uint32_t serial, struct wl_surface *surface)
+{
+       fprintf(stderr, &quot;keyboard leave\n&quot;);
+}
+
+static void
+wl_keyboard_modifiers(void *data, struct wl_keyboard *wl_keyboard,
+               uint32_t serial, uint32_t mods_depressed,
+               uint32_t mods_latched, uint32_t mods_locked,
+               uint32_t group)
+{
+       struct client_state *client_state = data;
+       xkb_state_update_mask(client_state-&gt;xkb_state,
+               mods_depressed, mods_latched, mods_locked, 0, 0, group);
+}
+
+static void
+wl_keyboard_repeat_info(void *data, struct wl_keyboard *wl_keyboard,
+               int32_t rate, int32_t delay)
+{
+       /* Left as an exercise for the reader */
+}
</code></pre>
<p>For modifiers, we could decode these further, but most applications won't need
to. We just update the XKB state here. As for handling key repeat — this
has a lot of constraints particular to your application. Do you want to repeat
text input? Do you want to repeat keyboard shortcuts? How does the timing of
these interact with your event loop? The answers to these questions is left for
you to decide.</p>
<p>If you compile this again, you should be able to start typing into the window
and see your input printed into the log. Huzzah!</p>
<h2 id="rigging-up-touch-events"><a class="header" href="#rigging-up-touch-events">Rigging up touch events</a></h2>
<p>Finally, we'll add support for touch-capable devices. Like pointers, a &quot;frame&quot;
event exists for touch devices. However, they're further complicated by the
possibility that multiple touch points may be updated within a single frame.
We'll add some more structures and enums to represent the accumulated state:</p>
<pre><code class="language-diff">+enum touch_event_mask {
+       TOUCH_EVENT_DOWN = 1 &lt;&lt; 0,
+       TOUCH_EVENT_UP = 1 &lt;&lt; 1,
+       TOUCH_EVENT_MOTION = 1 &lt;&lt; 2,
+       TOUCH_EVENT_CANCEL = 1 &lt;&lt; 3,
+       TOUCH_EVENT_SHAPE = 1 &lt;&lt; 4,
+       TOUCH_EVENT_ORIENTATION = 1 &lt;&lt; 5,
+};
+
+struct touch_point {
+       bool valid;
+       int32_t id;
+       uint32_t event_mask;
+       wl_fixed_t surface_x, surface_y;
+       wl_fixed_t major, minor;
+       wl_fixed_t orientation;
+};
+
+struct touch_event {
+       uint32_t event_mask;
+       uint32_t time;
+       uint32_t serial;
+       struct touch_point points[10];
+};
</code></pre>
<p>Note that I've arbitrarily chosen 10 touchpoints here, with the assumption that
most users will only ever use that many fingers. For larger, multi-user touch
screens, you may need a higher limit. Additionally, some touch hardware supports
fewer than 10 touch points concurrently — 8 is also common, and hardware
which supports fewer still is common among older devices.</p>
<p>We'll add this struct to <code>client_state</code>:</p>
<pre><code class="language-diff">@@ -110,6 +135,7 @@ struct client_state {
        struct xkb_state *xkb_state;
        struct xkb_context *xkb_context;
        struct xkb_keymap *xkb_keymap;
+       struct touch_event touch_event;
 };
</code></pre>
<p>And we'll update the seat capabilities handler to rig up a listener when touch
support is available.</p>
<pre><code class="language-diff">        } else if (!have_keyboard &amp;&amp; state-&gt;wl_keyboard != NULL) {
                wl_keyboard_release(state-&gt;wl_keyboard);
                state-&gt;wl_keyboard = NULL;
        }
+
+       bool have_touch = capabilities &amp; WL_SEAT_CAPABILITY_TOUCH;
+
+       if (have_touch &amp;&amp; state-&gt;wl_touch == NULL) {
+               state-&gt;wl_touch = wl_seat_get_touch(state-&gt;wl_seat);
+               wl_touch_add_listener(state-&gt;wl_touch,
+                               &amp;wl_touch_listener, state);
+       } else if (!have_touch &amp;&amp; state-&gt;wl_touch != NULL) {
+               wl_touch_release(state-&gt;wl_touch);
+               state-&gt;wl_touch = NULL;
+       }
 }
</code></pre>
<p>We've repeated again the pattern of handling both the appearance and
disappearance of touch capabilities on the seat, so we're robust to devices
appearing and disappearing at runtime. It's less common for touch devices to be
hotplugged, though.</p>
<p>Here's the listener itself:</p>
<pre><code class="language-diff">+static const struct wl_touch_listener wl_touch_listener = {
+       .down = wl_touch_down,
+       .up = wl_touch_up,
+       .motion = wl_touch_motion,
+       .frame = wl_touch_frame,
+       .cancel = wl_touch_cancel,
+       .shape = wl_touch_shape,
+       .orientation = wl_touch_orientation,
+};
</code></pre>
<p>To deal with multiple touch points, we'll need to write a small helper function:</p>
<pre><code class="language-diff">+static struct touch_point *
+get_touch_point(struct client_state *client_state, int32_t id)
+{
+       struct touch_event *touch = &amp;client_state-&gt;touch_event;
+       const size_t nmemb = sizeof(touch-&gt;points) / sizeof(struct touch_point);
+       int invalid = -1;
+       for (size_t i = 0; i &lt; nmemb; ++i) {
+               if (touch-&gt;points[i].id == id) {
+                       return &amp;touch-&gt;points[i];
+               }
+               if (invalid == -1 &amp;&amp; !touch-&gt;points[i].valid) {
+                       invalid = i;
+               }
+       }
+       if (invalid == -1) {
+               return NULL;
+       }
+       touch-&gt;points[invalid].valid = true;
+       touch-&gt;points[invalid].id = id;
+       return &amp;touch-&gt;points[invalid];
+}
</code></pre>
<p>The basic purpose of this function is to pick a <code>touch_point</code> from the array we
added to the <code>touch_event</code> struct, based on the touch ID we're receiving events
for. If we find an existing <code>touch_point</code> for that ID, we return it. If not, we
return the first available touch point. In case we run out, we return NULL.</p>
<p>Now we can take advantage of this to implement our first function: touch up.</p>
<pre><code class="language-diff">+static void
+wl_touch_down(void *data, struct wl_touch *wl_touch, uint32_t serial,
+               uint32_t time, struct wl_surface *surface, int32_t id,
+               wl_fixed_t x, wl_fixed_t y)
+{
+       struct client_state *client_state = data;
+       struct touch_point *point = get_touch_point(client_state, id);
+       if (point == NULL) {
+               return;
+       }
+       point-&gt;event_mask |= TOUCH_EVENT_UP;
+       point-&gt;surface_x = wl_fixed_to_double(x),
+               point-&gt;surface_y = wl_fixed_to_double(y);
+       client_state-&gt;touch_event.time = time;
+       client_state-&gt;touch_event.serial = serial;
+}
</code></pre>
<p>Like the pointer events, we're also simply accumulating this state for later
use. We don't yet know if this event represents a complete touch frame. Let's
add something similar for touch up:</p>
<pre><code class="language-diff">+static void
+wl_touch_up(void *data, struct wl_touch *wl_touch, uint32_t serial,
+               uint32_t time, int32_t id)
+{
+       struct client_state *client_state = data;
+       struct touch_point *point = get_touch_point(client_state, id);
+       if (point == NULL) {
+               return;
+       }
+       point-&gt;event_mask |= TOUCH_EVENT_UP;
+}
</code></pre>
<p>And for motion:</p>
<pre><code class="language-diff">+static void
+wl_touch_motion(void *data, struct wl_touch *wl_touch, uint32_t time,
+               int32_t id, wl_fixed_t x, wl_fixed_t y)
+{
+       struct client_state *client_state = data;
+       struct touch_point *point = get_touch_point(client_state, id);
+       if (point == NULL) {
+               return;
+       }
+       point-&gt;event_mask |= TOUCH_EVENT_MOTION;
+       point-&gt;surface_x = x, point-&gt;surface_y = y;
+       client_state-&gt;touch_event.time = time;
+}
</code></pre>
<p>The touch cancel event is somewhat different, as it &quot;cancels&quot; all active touch
points at once. We'll just store this in the <code>touch_event</code>'s top-level event
mask.</p>
<pre><code class="language-diff">+static void
+wl_touch_cancel(void *data, struct wl_touch *wl_touch)
+{
+       struct client_state *client_state = data;
+       client_state-&gt;touch_event.event_mask |= TOUCH_EVENT_CANCEL;
+}
</code></pre>
<p>The shape and orientation events are similar to up, down, and move, however, in
that they inform us about the dimensions of a specific touch point.</p>
<pre><code class="language-diff">+static void
+wl_touch_shape(void *data, struct wl_touch *wl_touch,
+               int32_t id, wl_fixed_t major, wl_fixed_t minor)
+{
+       struct client_state *client_state = data;
+       struct touch_point *point = get_touch_point(client_state, id);
+       if (point == NULL) {
+               return;
+       }
+       point-&gt;event_mask |= TOUCH_EVENT_SHAPE;
+       point-&gt;major = major, point-&gt;minor = minor;
+}
+
+static void
+wl_touch_orientation(void *data, struct wl_touch *wl_touch,
+               int32_t id, wl_fixed_t orientation)
+{
+       struct client_state *client_state = data;
+       struct touch_point *point = get_touch_point(client_state, id);
+       if (point == NULL) {
+               return;
+       }
+       point-&gt;event_mask |= TOUCH_EVENT_ORIENTATION;
+       point-&gt;orientation = orientation;
+}
</code></pre>
<p>And finally, upon receiving a frame event, we can interpret all of this
accumulated state as a single input event, much like our pointer code.</p>
<pre><code class="language-diff">+static void
+wl_touch_frame(void *data, struct wl_touch *wl_touch)
+{
+       struct client_state *client_state = data;
+       struct touch_event *touch = &amp;client_state-&gt;touch_event;
+       const size_t nmemb = sizeof(touch-&gt;points) / sizeof(struct touch_point);
+       fprintf(stderr, &quot;touch event @ %d:\n&quot;, touch-&gt;time);
+
+       for (size_t i = 0; i &lt; nmemb; ++i) {
+               struct touch_point *point = &amp;touch-&gt;points[i];
+               if (!point-&gt;valid) {
+                       continue;
+               }
+               fprintf(stderr, &quot;point %d: &quot;, touch-&gt;points[i].id);
+
+               if (point-&gt;event_mask &amp; TOUCH_EVENT_DOWN) {
+                       fprintf(stderr, &quot;down %f,%f &quot;,
+                                       wl_fixed_to_double(point-&gt;surface_x),
+                                       wl_fixed_to_double(point-&gt;surface_y));
+               }
+
+               if (point-&gt;event_mask &amp; TOUCH_EVENT_UP) {
+                       fprintf(stderr, &quot;up &quot;);
+               }
+
+               if (point-&gt;event_mask &amp; TOUCH_EVENT_MOTION) {
+                       fprintf(stderr, &quot;motion %f,%f &quot;,
+                                       wl_fixed_to_double(point-&gt;surface_x),
+                                       wl_fixed_to_double(point-&gt;surface_y));
+               }
+
+               if (point-&gt;event_mask &amp; TOUCH_EVENT_SHAPE) {
+                       fprintf(stderr, &quot;shape %fx%f &quot;,
+                                       wl_fixed_to_double(point-&gt;major),
+                                       wl_fixed_to_double(point-&gt;minor));
+               }
+
+               if (point-&gt;event_mask &amp; TOUCH_EVENT_ORIENTATION) {
+                       fprintf(stderr, &quot;orientation %f &quot;,
+                                       wl_fixed_to_double(point-&gt;orientation));
+               }
+
+               point-&gt;valid = false;
+               fprintf(stderr, &quot;\n&quot;);
+       }
+}
</code></pre>
<p>Compile and run this again, and you'll be able to see touch events printed to
stderr as you interact with your touch device (assuming you have such a device
to test with). And now our client supports input!</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's next?</a></h2>
<p>There are a lot of different kinds of input devices, so extending our code to
support them was a fair bit of work — our code has grown by 2.5× in
this chapter alone. The rewards should feel pretty great, though, as you are now
familiar with enough Wayland concepts (and code) that you can implement a lot of
clients.</p>
<p>There's still a little bit more to learn — in the last few chapters, we'll
cover popup windows, context menus, interactive window moving and resizing,
clipboard and drag &amp; drop support, and, later, a handful of interesting protocol
extensions which support more niche use-cases. I definitely recommend reading at
least chapter 10.1 before you start building your own client, as it covers
things like having the window resized at the compositor's request.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This actually does happen in practice!</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../seat/touch.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../xdg-shell-in-depth.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a href="../seat/touch.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a href="../xdg-shell-in-depth.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <script src="../book.js" type="text/javascript" charset="utf-8"></script>


    </body>
</html>
