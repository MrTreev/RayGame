<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shared memory buffers - The Wayland Protocol</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/high-level-design.html"><strong aria-hidden="true">1.1.</strong> High-level Wayland design</a></li><li class="chapter-item expanded "><a href="../introduction/goals.html"><strong aria-hidden="true">1.2.</strong> Goals & target audience</a></li><li class="chapter-item expanded "><a href="../introduction/package.html"><strong aria-hidden="true">1.3.</strong> What's in the package</a></li></ol></li><li class="chapter-item expanded "><a href="../protocol-design.html"><strong aria-hidden="true">2.</strong> Protocol design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../protocol-design/wire-protocol.html"><strong aria-hidden="true">2.1.</strong> Wire protocol basics</a></li><li class="chapter-item expanded "><a href="../protocol-design/interfaces-reqs-events.html"><strong aria-hidden="true">2.2.</strong> Interfaces, requests, events</a></li><li class="chapter-item expanded "><a href="../protocol-design/high-level.html"><strong aria-hidden="true">2.3.</strong> The high-level protocol</a></li><li class="chapter-item expanded "><a href="../protocol-design/design-patterns.html"><strong aria-hidden="true">2.4.</strong> Protocol design patterns</a></li></ol></li><li class="chapter-item expanded "><a href="../libwayland.html"><strong aria-hidden="true">3.</strong> libwayland in depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../libwayland/util.html"><strong aria-hidden="true">3.1.</strong> wayland-util primitives</a></li><li class="chapter-item expanded "><a href="../libwayland/wayland-scanner.html"><strong aria-hidden="true">3.2.</strong> wayland-scanner</a></li><li class="chapter-item expanded "><a href="../libwayland/proxies.html"><strong aria-hidden="true">3.3.</strong> Proxies & resources</a></li><li class="chapter-item expanded "><a href="../libwayland/interfaces.html"><strong aria-hidden="true">3.4.</strong> Interfaces & listeners</a></li></ol></li><li class="chapter-item expanded "><a href="../wayland-display.html"><strong aria-hidden="true">4.</strong> The Wayland display</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../wayland-display/creation.html"><strong aria-hidden="true">4.1.</strong> Creating a display</a></li><li class="chapter-item expanded "><a href="../wayland-display/event-loop.html"><strong aria-hidden="true">4.2.</strong> Incorporating an event loop</a></li></ol></li><li class="chapter-item expanded "><a href="../registry.html"><strong aria-hidden="true">5.</strong> Globals & the registry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../registry/binding.html"><strong aria-hidden="true">5.1.</strong> Binding to globals</a></li><li class="chapter-item expanded "><a href="../registry/server-side.html"><strong aria-hidden="true">5.2.</strong> Registering globals</a></li></ol></li><li class="chapter-item expanded "><a href="../surfaces.html"><strong aria-hidden="true">6.</strong> Buffers & surfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../surfaces/compositor.html"><strong aria-hidden="true">6.1.</strong> Using wl_compositor</a></li><li class="chapter-item expanded "><a href="../surfaces/shared-memory.html" class="active"><strong aria-hidden="true">6.2.</strong> Shared memory buffers</a></li><li class="chapter-item expanded "><a href="../surfaces/dmabuf.html"><strong aria-hidden="true">6.3.</strong> Linux dmabuf</a></li><li class="chapter-item expanded "><a href="../surfaces/roles.html"><strong aria-hidden="true">6.4.</strong> Surface roles</a></li></ol></li><li class="chapter-item expanded "><a href="../xdg-shell-basics.html"><strong aria-hidden="true">7.</strong> XDG shell basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../xdg-shell-basics/xdg-surface.html"><strong aria-hidden="true">7.1.</strong> XDG surfaces</a></li><li class="chapter-item expanded "><a href="../xdg-shell-basics/xdg-toplevel.html"><strong aria-hidden="true">7.2.</strong> Application windows</a></li><li class="chapter-item expanded "><a href="../xdg-shell-basics/example-code.html"><strong aria-hidden="true">7.3.</strong> Extended example code</a></li></ol></li><li class="chapter-item expanded "><a href="../surfaces-in-depth.html"><strong aria-hidden="true">8.</strong> Surfaces in depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../surfaces-in-depth/lifecycle.html"><strong aria-hidden="true">8.1.</strong> Surface lifecycle</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/frame-callbacks.html"><strong aria-hidden="true">8.2.</strong> Frame callbacks</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/damaging-surfaces.html"><strong aria-hidden="true">8.3.</strong> Damaging surfaces</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/surface-regions.html"><strong aria-hidden="true">8.4.</strong> Surface regions</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/subsurfaces.html"><strong aria-hidden="true">8.5.</strong> Subsurfaces</a></li><li class="chapter-item expanded "><a href="../surfaces-in-depth/hidpi.html"><strong aria-hidden="true">8.6.</strong> High density surfaces (HiDPI)</a></li></ol></li><li class="chapter-item expanded "><a href="../seat.html"><strong aria-hidden="true">9.</strong> Seats: Handling input</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../seat/pointer.html"><strong aria-hidden="true">9.1.</strong> Pointer input</a></li><li class="chapter-item expanded "><a href="../seat/xkb.html"><strong aria-hidden="true">9.2.</strong> XKB, briefly</a></li><li class="chapter-item expanded "><a href="../seat/keyboard.html"><strong aria-hidden="true">9.3.</strong> Keyboard input</a></li><li class="chapter-item expanded "><a href="../seat/touch.html"><strong aria-hidden="true">9.4.</strong> Touch input</a></li><li class="chapter-item expanded "><a href="../seat/example.html"><strong aria-hidden="true">9.5.</strong> Expanding our example code</a></li></ol></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth.html"><strong aria-hidden="true">10.</strong> XDG shell in depth</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/configuration.html"><strong aria-hidden="true">10.1.</strong> Configuration & lifecycle</a></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/popups.html"><strong aria-hidden="true">10.2.</strong> Popups & parent windows</a></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/interactive.html"><strong aria-hidden="true">10.3.</strong> Interactive move and resize</a></li><li class="chapter-item expanded "><a href="../xdg-shell-in-depth/positioners.html"><strong aria-hidden="true">10.4.</strong> Positioners</a></li></ol></li><li class="chapter-item expanded "><a href="../clipboard.html"><strong aria-hidden="true">11.</strong> Clipboard access</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../clipboard/data-offers.html"><strong aria-hidden="true">11.1.</strong> Data offers</a></li><li class="chapter-item expanded "><a href="../clipboard/dnd.html"><strong aria-hidden="true">11.2.</strong> Drag & drop</a></li></ol></li><li class="chapter-item expanded "><a href="../protocol-extensions.html"><strong aria-hidden="true">12.</strong> Protocol extensions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../protocol-extensions/timing.html"><strong aria-hidden="true">12.1.</strong> Accurate timing</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/pointer-constraints.html"><strong aria-hidden="true">12.2.</strong> Pointer constraints</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/clipboard.html"><strong aria-hidden="true">12.3.</strong> Extended clipboard support</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/desktop-shell.html"><strong aria-hidden="true">12.4.</strong> Desktop shell components</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/misc.html"><strong aria-hidden="true">12.5.</strong> Miscellaneous extensions</a></li><li class="chapter-item expanded "><a href="../protocol-extensions/writing.html"><strong aria-hidden="true">12.6.</strong> Writing new extensions</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="../acknowledgements.html">Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <h1 class="menu-title">The Wayland Protocol</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="shared-memory-buffers"><a class="header" href="#shared-memory-buffers">Shared memory buffers</a></h1>
<p>The simplest means of getting pixels from client to compositor, and the only one
enshrined in <code>wayland.xml</code>, is <code>wl_shm</code> — shared memory. Simply put, it 
allows you to transfer a file descriptor for the compositor to mmap with 
<code>MAP_SHARED</code>, then share pixel buffers out of this pool. Add some simple 
synchronization primitives to keep everyone from fighting over each buffer, and 
you have a workable — and portable — solution.</p>
<h2 id="binding-to-wl_shm"><a class="header" href="#binding-to-wl_shm">Binding to wl_shm</a></h2>
<p>The registry global listener explained in chapter 5.1 will advertise the
<code>wl_shm</code> global when it's available. Binding to it is fairly straightforward.
Extending the example given in chapter 5.1, we get the following:</p>
<pre><code>struct our_state {
    // ...
    struct wl_shm *shm;
    // ...
};

static void
registry_handle_global(void *data, struct wl_registry *registry,
		uint32_t name, const char *interface, uint32_t version)
{
    struct our_state *state = data;
    if (strcmp(interface, wl_shm_interface.name) == 0) {
        state-&gt;shm = wl_registry_bind(
            wl_registry, name, &amp;wl_shm_interface, 1);
    }
}

int
main(int argc, char *argv[])
{
    struct our_state state = { 0 };
    // ...
    wl_registry_add_listener(registry, &amp;registry_listener, &amp;state);
    // ...
}
</code></pre>
<p>Once bound, we can optionally add a listener via <code>wl_shm_add_listener</code>. The
compositor will advertise its supported pixel formats via this listener. The
full list of possible pixel formats is given in <code>wayland.xml</code>. Two formats are
required to be supported: <code>ARGB8888</code>, and <code>XRGB8888</code>, which are 24-bit color,
with and without an alpha channel respectively.</p>
<h2 id="allocating-a-shared-memory-pool"><a class="header" href="#allocating-a-shared-memory-pool">Allocating a shared memory pool</a></h2>
<p>A combination of POSIX <code>shm_open</code> and random file names can be utilized to
create a file suitable for this purpose, and <code>ftruncate</code> can be utilized to
bring it up to the appropriate size. The following boilerplate may be freely
used under public domain or CC0:</p>
<pre><code>#define _POSIX_C_SOURCE 200112L
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;

static void
randname(char *buf)
{
	struct timespec ts;
	clock_gettime(CLOCK_REALTIME, &amp;ts);
	long r = ts.tv_nsec;
	for (int i = 0; i &lt; 6; ++i) {
		buf[i] = 'A'+(r&amp;15)+(r&amp;16)*2;
		r &gt;&gt;= 5;
	}
}

static int
create_shm_file(void)
{
	int retries = 100;
	do {
		char name[] = &quot;/wl_shm-XXXXXX&quot;;
		randname(name + sizeof(name) - 7);
		--retries;
		int fd = shm_open(name, O_RDWR | O_CREAT | O_EXCL, 0600);
		if (fd &gt;= 0) {
			shm_unlink(name);
			return fd;
		}
	} while (retries &gt; 0 &amp;&amp; errno == EEXIST);
	return -1;
}

int
allocate_shm_file(size_t size)
{
	int fd = create_shm_file();
	if (fd &lt; 0)
		return -1;
	int ret;
	do {
		ret = ftruncate(fd, size);
	} while (ret &lt; 0 &amp;&amp; errno == EINTR);
	if (ret &lt; 0) {
		close(fd);
		return -1;
	}
	return fd;
}
</code></pre>
<p>Hopefully the code is fairly self-explanatory (famous last words). Armed with
this, the client can create a shared memory pool fairly easily. Let's say, for
example, that we want to show a 1920x1080 window. We'll need two buffers for
double-buffering, so that'll be 4,147,200 pixels. Assuming the pixel format is
<code>WL_SHM_FORMAT_XRGB8888</code>, that'll be 4 bytes to the pixel, for a total pool size
of 16,588,800 bytes. Bind to the <code>wl_shm</code> global from the registry as explained
in chapter 5.1, then use it like so to create an shm pool which can hold these
buffers:</p>
<pre><code>const int width = 1920, height = 1080;
const int stride = width * 4;
const int shm_pool_size = height * stride * 2;

int fd = allocate_shm_file(shm_pool_size);
uint8_t *pool_data = mmap(NULL, shm_pool_size,
    PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

struct wl_shm *shm = ...; // Bound from registry
struct wl_shm_pool *pool = wl_shm_create_pool(shm, fd, shm_pool_size);
</code></pre>
<h2 id="creating-buffers-from-a-pool"><a class="header" href="#creating-buffers-from-a-pool">Creating buffers from a pool</a></h2>
<p>Once word of this gets to the compositor, it will <code>mmap</code> this file descriptor as
well. Wayland is asynchronous, though, so we can start allocating buffers from
this pool right away. Since we allocated space for two buffers, we can assign
each an index and convert that index into a byte offset in the pool. Equipped
with this information, we can create a <code>wl_buffer</code>:</p>
<pre><code>int index = 0;
int offset = height * stride * index;
struct wl_buffer *buffer = wl_shm_pool_create_buffer(pool, offset,
    width, height, stride, WL_SHM_FORMAT_XRGB8888);
</code></pre>
<p>We can write an image to this buffer now as well. For example, to set it to
solid white:</p>
<pre><code>uint32_t *pixels = (uint32_t *)&amp;pool_data[offset];
memset(pixels, 0, width * height * 4);
</code></pre>
<p>Or, for something more interesting, here's a checkerboard pattern:</p>
<pre><code>uint32_t *pixels = (uint32_t *)&amp;pool_data[offset];
for (int y = 0; y &lt; height; ++y) {
  for (int x = 0; x &lt; width; ++x) {
    if ((x + y / 8 * 8) % 16 &lt; 8) {
      pixels[y * width + x] = 0xFF666666;
    } else {
      pixels[y * width + x] = 0xFFEEEEEE;
    }
  }
}
</code></pre>
<p>With the stage set, we'll attach our buffer to our surface, mark the whole
surface as damaged<sup class="footnote-reference"><a href="#1">1</a></sup>, and commit it:</p>
<pre><code class="language-c">wl_surface_attach(surface, buffer, 0, 0);
wl_surface_damage(surface, 0, 0, UINT32_MAX, UINT32_MAX);
wl_surface_commit(surface);
</code></pre>
<p>If you were to apply all of this newfound knowledge to writing a Wayland client
yourself, you may arrive at this point confused when your buffer is not shown
on-screen. We're missing a critical final step — assigning your surface a
role.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>&quot;Damaged&quot; meaning &quot;this area needs to be redrawn&quot;</p>
</div>
<h2 id="wl_shm-on-the-server"><a class="header" href="#wl_shm-on-the-server">wl_shm on the server</a></h2>
<p>Before we get there, however, the server-side part of this deserves note.
libwayland provides some helpers to make using <code>wl_shm</code> easier. To configure it
for your display, it only requires the following:</p>
<pre><code>int
wl_display_init_shm(struct wl_display *display);

uint32_t *
wl_display_add_shm_format(struct wl_display *display, uint32_t format);
</code></pre>
<p>The former creates the global and rigs up the internal implementation, and the
latter adds a supported pixel format (remember to at least add ARGB8888 and
XRGB8888). Once a client attaches a buffer to one of its surfaces, you can pass
the buffer resource into <code>wl_shm_buffer_get</code> to obtain a <code>wl_shm_buffer</code>
reference, and utilize it like so:</p>
<pre><code>void
wl_shm_buffer_begin_access(struct wl_shm_buffer *buffer);

void
wl_shm_buffer_end_access(struct wl_shm_buffer *buffer);

void *
wl_shm_buffer_get_data(struct wl_shm_buffer *buffer);

int32_t
wl_shm_buffer_get_stride(struct wl_shm_buffer *buffer);

uint32_t
wl_shm_buffer_get_format(struct wl_shm_buffer *buffer);

int32_t
wl_shm_buffer_get_width(struct wl_shm_buffer *buffer);

int32_t
wl_shm_buffer_get_height(struct wl_shm_buffer *buffer);
</code></pre>
<p>If you guard your accesses to the buffer data with <code>begin_access</code> and
<code>end_access</code>, libwayland will take care of locking for you.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../surfaces/compositor.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../surfaces/dmabuf.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a href="../surfaces/compositor.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a href="../surfaces/dmabuf.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <script src="../book.js" type="text/javascript" charset="utf-8"></script>


    </body>
</html>
